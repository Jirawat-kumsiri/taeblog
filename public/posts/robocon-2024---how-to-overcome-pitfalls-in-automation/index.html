<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Title of the post - Teiiz</title><link rel="icon" type="image/png" href=/icons/penguin.png /><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="SUMMARY
Guido and Frank discuss their lessons from implementing and improving test automation using Robot Framework over years, emphasizing best practices and conventions.
IDEAS

Effective automation starts with organizing test cases and separating reusable components into resource files.
Avoid direct communication between test cases and the system; use intermediary resource files.
Logical separation of files, such as screens, common actions, and shared functionality, enhances maintainability.
Keep resource files compact, readable, and maintainable by splitting large functionalities into smaller files.
Centralize locators within single-action keywords to minimize duplication and reduce locator management complexity.
Composite keywords should check their completion status to ensure subsequent tests run without errors.
Start each keyword with validation to confirm the proper context or screen before execution.
Naming conventions for single-action keywords aid clarity and understanding in test suites.
Separate technical details and business logic into distinct layers for clarity and stakeholder involvement.
Stakeholder-friendly &ldquo;business object&rdquo; resource files should focus on functional, non-technical details.
Technical details, like locators and logic, belong in &ldquo;page object&rdquo; resource files.
&ldquo;Assertion layer&rdquo; ensures functional correctness without cluttering business objects.
Prefix validation keywords with clear terms like &ldquo;validate&rdquo; to distinguish them in tests.
Use directory-level test execution to organize and manage extensive end-to-end test setups.
Split long end-to-end tests into modular test suites for flexibility and easier debugging.
Keep setup and teardown logic outside test suites for clarity in specific test validations.
Maintain stakeholder involvement by using their language in business layer test definitions.
Utilize prefixes in resource file keywords to resolve ambiguous names and improve readability.
Collaborate with developers to avoid the need for dynamic locators, simplifying automation.
Domain language capture in the business layer facilitates alignment between testers and stakeholders.
Modular testing ensures resilience against system changes by isolating specific functionalities.
Define conventions for layer separation to enable maintainable and scalable test frameworks.
Use consistent naming for validation steps to streamline debugging and stakeholder understanding.
Dynamic fields can be handled with title-based locators or parametrized validations.
JSON transfers between systems help align real-world application interactions and test automation.
Modular test files ease switching components when applications are temporarily unavailable.

INSIGHTS

Separation of business logic and technical details builds frameworks readable for both testers and stakeholders.
Modularization and logical resource file organization ensure long-term test maintainability and clarity.
Collaboration with developers reduces automation complexity and improves locator stability.
Business layer clarity fosters better communication and alignment between technical and non-technical teams.
Validation at every step prevents silent failures and ensures more robust test outcomes.
Prefixes in keyword naming avoid ambiguities and improve framework scalability.
Layered architecture facilitates parallel test case development and system readiness checks.
Assertions should be explicit and clearly identified to improve test integrity and results clarity.
End-to-end tests should be modular, not monolithic, for resilience and easier maintenance.
Stakeholder language integration in business layers builds trust and improves test case relevance.

QUOTES

&ldquo;The fastest way to drop jaws is showing manual testers automated clicks.&rdquo;
&ldquo;Keywords must finish themselves to ensure the next ones won’t fail prematurely.&rdquo;
&ldquo;Keep resource files compact, readable, and maintainable by splitting larger functionalities.&rdquo;
&ldquo;The business object layer should only contain functional descriptions stakeholders understand.&rdquo;
&ldquo;Ambiguous keywords are a nightmare; use naming prefixes to resolve conflicts.&rdquo;
&ldquo;Validation steps must ensure system correctness without cluttering the business layer.&rdquo;
&ldquo;Stakeholders should not look at us like rabbits before an 18-ton truck.&rdquo;
&ldquo;Separate technical details from functionality to make test cases readable by stakeholders.&rdquo;
&ldquo;Test cases should end with validation keywords to confirm they achieved their purpose.&rdquo;
&ldquo;Dynamic locators should be avoided whenever possible through collaboration with developers.&rdquo;
&ldquo;Composite keywords must check if actions are complete before moving on.&rdquo;
&ldquo;Resource files must align with business layers for clarity and modularity.&rdquo;
&ldquo;Assertions are for testers, while business objects cater to stakeholder understanding.&rdquo;
&ldquo;Layer separation facilitates simultaneous test case creation and system readiness testing.&rdquo;
&ldquo;Organize long end-to-end tests into modular files for flexibility and clarity.&rdquo;

HABITS

Collaborate with developers early to simplify automation and avoid dynamic locators.
Use clear naming conventions for single-action and composite keywords to improve clarity.
Validate each test keyword’s context and outcome before advancing to the next step.
Modularize tests into small, maintainable resource files for easier debugging and updates.
Separate technical complexities into page objects to reduce stakeholder confusion.
Use logical naming prefixes for keywords and files to resolve potential ambiguities.
Align test terminology with stakeholder language to ensure mutual understanding.
Create assertions as separate validation layers to confirm functional correctness.
Modularize end-to-end tests into smaller test suites for scalability and resilience.
Reserve test setup and teardown actions for designated files outside the core tests.
Prefix assertion keywords with terms like “validate” for immediate recognition.
Consolidate locator usage within keywords to reduce redundancy and errors.
Develop tests incrementally to parallelize work on system readiness and test case creation.
Utilize consistent conventions for page and business object layers to enhance readability.

FACTS

Robot Framework allows modularization through resource file organization for better test management.
Test locators can often be simplified by avoiding dynamic parameters with developer collaboration.
Stakeholders may find technical test scripts overwhelming without functional abstraction layers.
Composite keywords must ensure their completion status before the next test step begins.
Modular test frameworks enable switching out unavailable or incomplete system components.
Validation steps are vital for ensuring test outcomes reflect real system behavior.
JSON is often used for system-to-system data transfer in end-to-end tests.
Consistent naming conventions in test frameworks improve scalability and reduce ambiguity.
Modularized end-to-end testing eases debugging and reduces system interdependencies.
Prefixes like &ldquo;validate&rdquo; distinguish validation steps from core test actions.

REFERENCES

Robot Framework documentation and best practices.
JSON as a format for system-to-system communication.
Giren language concepts for capturing stakeholder language in test layers.
Page Object and Business Object design patterns in test automation.

ONE-SENTENCE TAKEAWAY
Effective test automation frameworks rely on clear modularization, stakeholder alignment, and robust conventions for maintainability." />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="https://teiiz.com/posts/robocon-2024---how-to-overcome-pitfalls-in-automation/">
  <meta property="og:site_name" content="Teiiz">
  <meta property="og:title" content="Title of the post">
  <meta property="og:description" content="SUMMARY Guido and Frank discuss their lessons from implementing and improving test automation using Robot Framework over years, emphasizing best practices and conventions.
IDEAS Effective automation starts with organizing test cases and separating reusable components into resource files. Avoid direct communication between test cases and the system; use intermediary resource files. Logical separation of files, such as screens, common actions, and shared functionality, enhances maintainability. Keep resource files compact, readable, and maintainable by splitting large functionalities into smaller files. Centralize locators within single-action keywords to minimize duplication and reduce locator management complexity. Composite keywords should check their completion status to ensure subsequent tests run without errors. Start each keyword with validation to confirm the proper context or screen before execution. Naming conventions for single-action keywords aid clarity and understanding in test suites. Separate technical details and business logic into distinct layers for clarity and stakeholder involvement. Stakeholder-friendly “business object” resource files should focus on functional, non-technical details. Technical details, like locators and logic, belong in “page object” resource files. “Assertion layer” ensures functional correctness without cluttering business objects. Prefix validation keywords with clear terms like “validate” to distinguish them in tests. Use directory-level test execution to organize and manage extensive end-to-end test setups. Split long end-to-end tests into modular test suites for flexibility and easier debugging. Keep setup and teardown logic outside test suites for clarity in specific test validations. Maintain stakeholder involvement by using their language in business layer test definitions. Utilize prefixes in resource file keywords to resolve ambiguous names and improve readability. Collaborate with developers to avoid the need for dynamic locators, simplifying automation. Domain language capture in the business layer facilitates alignment between testers and stakeholders. Modular testing ensures resilience against system changes by isolating specific functionalities. Define conventions for layer separation to enable maintainable and scalable test frameworks. Use consistent naming for validation steps to streamline debugging and stakeholder understanding. Dynamic fields can be handled with title-based locators or parametrized validations. JSON transfers between systems help align real-world application interactions and test automation. Modular test files ease switching components when applications are temporarily unavailable. INSIGHTS Separation of business logic and technical details builds frameworks readable for both testers and stakeholders. Modularization and logical resource file organization ensure long-term test maintainability and clarity. Collaboration with developers reduces automation complexity and improves locator stability. Business layer clarity fosters better communication and alignment between technical and non-technical teams. Validation at every step prevents silent failures and ensures more robust test outcomes. Prefixes in keyword naming avoid ambiguities and improve framework scalability. Layered architecture facilitates parallel test case development and system readiness checks. Assertions should be explicit and clearly identified to improve test integrity and results clarity. End-to-end tests should be modular, not monolithic, for resilience and easier maintenance. Stakeholder language integration in business layers builds trust and improves test case relevance. QUOTES “The fastest way to drop jaws is showing manual testers automated clicks.” “Keywords must finish themselves to ensure the next ones won’t fail prematurely.” “Keep resource files compact, readable, and maintainable by splitting larger functionalities.” “The business object layer should only contain functional descriptions stakeholders understand.” “Ambiguous keywords are a nightmare; use naming prefixes to resolve conflicts.” “Validation steps must ensure system correctness without cluttering the business layer.” “Stakeholders should not look at us like rabbits before an 18-ton truck.” “Separate technical details from functionality to make test cases readable by stakeholders.” “Test cases should end with validation keywords to confirm they achieved their purpose.” “Dynamic locators should be avoided whenever possible through collaboration with developers.” “Composite keywords must check if actions are complete before moving on.” “Resource files must align with business layers for clarity and modularity.” “Assertions are for testers, while business objects cater to stakeholder understanding.” “Layer separation facilitates simultaneous test case creation and system readiness testing.” “Organize long end-to-end tests into modular files for flexibility and clarity.” HABITS Collaborate with developers early to simplify automation and avoid dynamic locators. Use clear naming conventions for single-action and composite keywords to improve clarity. Validate each test keyword’s context and outcome before advancing to the next step. Modularize tests into small, maintainable resource files for easier debugging and updates. Separate technical complexities into page objects to reduce stakeholder confusion. Use logical naming prefixes for keywords and files to resolve potential ambiguities. Align test terminology with stakeholder language to ensure mutual understanding. Create assertions as separate validation layers to confirm functional correctness. Modularize end-to-end tests into smaller test suites for scalability and resilience. Reserve test setup and teardown actions for designated files outside the core tests. Prefix assertion keywords with terms like “validate” for immediate recognition. Consolidate locator usage within keywords to reduce redundancy and errors. Develop tests incrementally to parallelize work on system readiness and test case creation. Utilize consistent conventions for page and business object layers to enhance readability. FACTS Robot Framework allows modularization through resource file organization for better test management. Test locators can often be simplified by avoiding dynamic parameters with developer collaboration. Stakeholders may find technical test scripts overwhelming without functional abstraction layers. Composite keywords must ensure their completion status before the next test step begins. Modular test frameworks enable switching out unavailable or incomplete system components. Validation steps are vital for ensuring test outcomes reflect real system behavior. JSON is often used for system-to-system data transfer in end-to-end tests. Consistent naming conventions in test frameworks improve scalability and reduce ambiguity. Modularized end-to-end testing eases debugging and reduces system interdependencies. Prefixes like “validate” distinguish validation steps from core test actions. REFERENCES Robot Framework documentation and best practices. JSON as a format for system-to-system communication. Giren language concepts for capturing stakeholder language in test layers. Page Object and Business Object design patterns in test automation. ONE-SENTENCE TAKEAWAY Effective test automation frameworks rely on clear modularization, stakeholder alignment, and robust conventions for maintainability.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Tag">
    <meta property="article:tag" content="Names">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Title of the post">
  <meta name="twitter:description" content="SUMMARY Guido and Frank discuss their lessons from implementing and improving test automation using Robot Framework over years, emphasizing best practices and conventions.
IDEAS Effective automation starts with organizing test cases and separating reusable components into resource files. Avoid direct communication between test cases and the system; use intermediary resource files. Logical separation of files, such as screens, common actions, and shared functionality, enhances maintainability. Keep resource files compact, readable, and maintainable by splitting large functionalities into smaller files. Centralize locators within single-action keywords to minimize duplication and reduce locator management complexity. Composite keywords should check their completion status to ensure subsequent tests run without errors. Start each keyword with validation to confirm the proper context or screen before execution. Naming conventions for single-action keywords aid clarity and understanding in test suites. Separate technical details and business logic into distinct layers for clarity and stakeholder involvement. Stakeholder-friendly “business object” resource files should focus on functional, non-technical details. Technical details, like locators and logic, belong in “page object” resource files. “Assertion layer” ensures functional correctness without cluttering business objects. Prefix validation keywords with clear terms like “validate” to distinguish them in tests. Use directory-level test execution to organize and manage extensive end-to-end test setups. Split long end-to-end tests into modular test suites for flexibility and easier debugging. Keep setup and teardown logic outside test suites for clarity in specific test validations. Maintain stakeholder involvement by using their language in business layer test definitions. Utilize prefixes in resource file keywords to resolve ambiguous names and improve readability. Collaborate with developers to avoid the need for dynamic locators, simplifying automation. Domain language capture in the business layer facilitates alignment between testers and stakeholders. Modular testing ensures resilience against system changes by isolating specific functionalities. Define conventions for layer separation to enable maintainable and scalable test frameworks. Use consistent naming for validation steps to streamline debugging and stakeholder understanding. Dynamic fields can be handled with title-based locators or parametrized validations. JSON transfers between systems help align real-world application interactions and test automation. Modular test files ease switching components when applications are temporarily unavailable. INSIGHTS Separation of business logic and technical details builds frameworks readable for both testers and stakeholders. Modularization and logical resource file organization ensure long-term test maintainability and clarity. Collaboration with developers reduces automation complexity and improves locator stability. Business layer clarity fosters better communication and alignment between technical and non-technical teams. Validation at every step prevents silent failures and ensures more robust test outcomes. Prefixes in keyword naming avoid ambiguities and improve framework scalability. Layered architecture facilitates parallel test case development and system readiness checks. Assertions should be explicit and clearly identified to improve test integrity and results clarity. End-to-end tests should be modular, not monolithic, for resilience and easier maintenance. Stakeholder language integration in business layers builds trust and improves test case relevance. QUOTES “The fastest way to drop jaws is showing manual testers automated clicks.” “Keywords must finish themselves to ensure the next ones won’t fail prematurely.” “Keep resource files compact, readable, and maintainable by splitting larger functionalities.” “The business object layer should only contain functional descriptions stakeholders understand.” “Ambiguous keywords are a nightmare; use naming prefixes to resolve conflicts.” “Validation steps must ensure system correctness without cluttering the business layer.” “Stakeholders should not look at us like rabbits before an 18-ton truck.” “Separate technical details from functionality to make test cases readable by stakeholders.” “Test cases should end with validation keywords to confirm they achieved their purpose.” “Dynamic locators should be avoided whenever possible through collaboration with developers.” “Composite keywords must check if actions are complete before moving on.” “Resource files must align with business layers for clarity and modularity.” “Assertions are for testers, while business objects cater to stakeholder understanding.” “Layer separation facilitates simultaneous test case creation and system readiness testing.” “Organize long end-to-end tests into modular files for flexibility and clarity.” HABITS Collaborate with developers early to simplify automation and avoid dynamic locators. Use clear naming conventions for single-action and composite keywords to improve clarity. Validate each test keyword’s context and outcome before advancing to the next step. Modularize tests into small, maintainable resource files for easier debugging and updates. Separate technical complexities into page objects to reduce stakeholder confusion. Use logical naming prefixes for keywords and files to resolve potential ambiguities. Align test terminology with stakeholder language to ensure mutual understanding. Create assertions as separate validation layers to confirm functional correctness. Modularize end-to-end tests into smaller test suites for scalability and resilience. Reserve test setup and teardown actions for designated files outside the core tests. Prefix assertion keywords with terms like “validate” for immediate recognition. Consolidate locator usage within keywords to reduce redundancy and errors. Develop tests incrementally to parallelize work on system readiness and test case creation. Utilize consistent conventions for page and business object layers to enhance readability. FACTS Robot Framework allows modularization through resource file organization for better test management. Test locators can often be simplified by avoiding dynamic parameters with developer collaboration. Stakeholders may find technical test scripts overwhelming without functional abstraction layers. Composite keywords must ensure their completion status before the next test step begins. Modular test frameworks enable switching out unavailable or incomplete system components. Validation steps are vital for ensuring test outcomes reflect real system behavior. JSON is often used for system-to-system data transfer in end-to-end tests. Consistent naming conventions in test frameworks improve scalability and reduce ambiguity. Modularized end-to-end testing eases debugging and reduces system interdependencies. Prefixes like “validate” distinguish validation steps from core test actions. REFERENCES Robot Framework documentation and best practices. JSON as a format for system-to-system communication. Giren language concepts for capturing stakeholder language in test layers. Page Object and Business Object design patterns in test automation. ONE-SENTENCE TAKEAWAY Effective test automation frameworks rely on clear modularization, stakeholder alignment, and robust conventions for maintainability.">
<script src="https://teiiz.com/js/feather.min.js"></script>
	
	
        <link href="https://teiiz.com/css/fonts.11a1877508139eac0b5b4852ceb110c35641b3533321e66e39149e901ed5756b.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://teiiz.com/css/main.fa747a9bb099b7bfd5d71b78a6e8ca2e23a425384e48bf533f1d357aeb61d265.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://teiiz.com/css/dark.acc27faeb64bfb288fd545d29d5ec804495d962a1c2bee862cc5f8270ee6f6f8.css"   />
	

	
	
		<script type="text/javascript"
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>

		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
	

	
	
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$$", right: "$$", display: true},
									{left: "$", right: "$", display: false}
							]
					});
			});
			</script>
	

	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://teiiz.com/">Teiiz</a>
	</div>
	<nav>
		
		<a href="https://teiiz.com/">Home</a>
		
		<a href="https://teiiz.com/posts/">All posts</a>
		
		<a href="https://teiiz.com/tags/">Tags</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Title of the post</h1>
			<div class="meta">Posted on Nov 6, 2024</div>
		</div>
		
		<div class="tldr">
			<strong>tl;dr:</strong>
			
		</div>

		
		<div class="toc">
		<strong>Table of contents:</strong>
		<nav id="TableOfContents">
  <ul>
    <li><a href="#summary">SUMMARY</a></li>
    <li><a href="#ideas">IDEAS</a></li>
    <li><a href="#insights">INSIGHTS</a></li>
    <li><a href="#quotes">QUOTES</a></li>
    <li><a href="#habits">HABITS</a></li>
    <li><a href="#facts">FACTS</a></li>
    <li><a href="#references">REFERENCES</a></li>
    <li><a href="#one-sentence-takeaway">ONE-SENTENCE TAKEAWAY</a></li>
    <li><a href="#recommendations">RECOMMENDATIONS</a></li>
  </ul>
</nav>
		</div>

		<section class="body">
			<h2 id="summary">SUMMARY</h2>
<p>Guido and Frank discuss their lessons from implementing and improving test automation using Robot Framework over years, emphasizing best practices and conventions.</p>
<h2 id="ideas">IDEAS</h2>
<ul>
<li>Effective automation starts with organizing test cases and separating reusable components into resource files.</li>
<li>Avoid direct communication between test cases and the system; use intermediary resource files.</li>
<li>Logical separation of files, such as screens, common actions, and shared functionality, enhances maintainability.</li>
<li>Keep resource files compact, readable, and maintainable by splitting large functionalities into smaller files.</li>
<li>Centralize locators within single-action keywords to minimize duplication and reduce locator management complexity.</li>
<li>Composite keywords should check their completion status to ensure subsequent tests run without errors.</li>
<li>Start each keyword with validation to confirm the proper context or screen before execution.</li>
<li>Naming conventions for single-action keywords aid clarity and understanding in test suites.</li>
<li>Separate technical details and business logic into distinct layers for clarity and stakeholder involvement.</li>
<li>Stakeholder-friendly &ldquo;business object&rdquo; resource files should focus on functional, non-technical details.</li>
<li>Technical details, like locators and logic, belong in &ldquo;page object&rdquo; resource files.</li>
<li>&ldquo;Assertion layer&rdquo; ensures functional correctness without cluttering business objects.</li>
<li>Prefix validation keywords with clear terms like &ldquo;validate&rdquo; to distinguish them in tests.</li>
<li>Use directory-level test execution to organize and manage extensive end-to-end test setups.</li>
<li>Split long end-to-end tests into modular test suites for flexibility and easier debugging.</li>
<li>Keep setup and teardown logic outside test suites for clarity in specific test validations.</li>
<li>Maintain stakeholder involvement by using their language in business layer test definitions.</li>
<li>Utilize prefixes in resource file keywords to resolve ambiguous names and improve readability.</li>
<li>Collaborate with developers to avoid the need for dynamic locators, simplifying automation.</li>
<li>Domain language capture in the business layer facilitates alignment between testers and stakeholders.</li>
<li>Modular testing ensures resilience against system changes by isolating specific functionalities.</li>
<li>Define conventions for layer separation to enable maintainable and scalable test frameworks.</li>
<li>Use consistent naming for validation steps to streamline debugging and stakeholder understanding.</li>
<li>Dynamic fields can be handled with title-based locators or parametrized validations.</li>
<li>JSON transfers between systems help align real-world application interactions and test automation.</li>
<li>Modular test files ease switching components when applications are temporarily unavailable.</li>
</ul>
<h2 id="insights">INSIGHTS</h2>
<ul>
<li>Separation of business logic and technical details builds frameworks readable for both testers and stakeholders.</li>
<li>Modularization and logical resource file organization ensure long-term test maintainability and clarity.</li>
<li>Collaboration with developers reduces automation complexity and improves locator stability.</li>
<li>Business layer clarity fosters better communication and alignment between technical and non-technical teams.</li>
<li>Validation at every step prevents silent failures and ensures more robust test outcomes.</li>
<li>Prefixes in keyword naming avoid ambiguities and improve framework scalability.</li>
<li>Layered architecture facilitates parallel test case development and system readiness checks.</li>
<li>Assertions should be explicit and clearly identified to improve test integrity and results clarity.</li>
<li>End-to-end tests should be modular, not monolithic, for resilience and easier maintenance.</li>
<li>Stakeholder language integration in business layers builds trust and improves test case relevance.</li>
</ul>
<h2 id="quotes">QUOTES</h2>
<ul>
<li>&ldquo;The fastest way to drop jaws is showing manual testers automated clicks.&rdquo;</li>
<li>&ldquo;Keywords must finish themselves to ensure the next ones won’t fail prematurely.&rdquo;</li>
<li>&ldquo;Keep resource files compact, readable, and maintainable by splitting larger functionalities.&rdquo;</li>
<li>&ldquo;The business object layer should only contain functional descriptions stakeholders understand.&rdquo;</li>
<li>&ldquo;Ambiguous keywords are a nightmare; use naming prefixes to resolve conflicts.&rdquo;</li>
<li>&ldquo;Validation steps must ensure system correctness without cluttering the business layer.&rdquo;</li>
<li>&ldquo;Stakeholders should not look at us like rabbits before an 18-ton truck.&rdquo;</li>
<li>&ldquo;Separate technical details from functionality to make test cases readable by stakeholders.&rdquo;</li>
<li>&ldquo;Test cases should end with validation keywords to confirm they achieved their purpose.&rdquo;</li>
<li>&ldquo;Dynamic locators should be avoided whenever possible through collaboration with developers.&rdquo;</li>
<li>&ldquo;Composite keywords must check if actions are complete before moving on.&rdquo;</li>
<li>&ldquo;Resource files must align with business layers for clarity and modularity.&rdquo;</li>
<li>&ldquo;Assertions are for testers, while business objects cater to stakeholder understanding.&rdquo;</li>
<li>&ldquo;Layer separation facilitates simultaneous test case creation and system readiness testing.&rdquo;</li>
<li>&ldquo;Organize long end-to-end tests into modular files for flexibility and clarity.&rdquo;</li>
</ul>
<h2 id="habits">HABITS</h2>
<ul>
<li>Collaborate with developers early to simplify automation and avoid dynamic locators.</li>
<li>Use clear naming conventions for single-action and composite keywords to improve clarity.</li>
<li>Validate each test keyword’s context and outcome before advancing to the next step.</li>
<li>Modularize tests into small, maintainable resource files for easier debugging and updates.</li>
<li>Separate technical complexities into page objects to reduce stakeholder confusion.</li>
<li>Use logical naming prefixes for keywords and files to resolve potential ambiguities.</li>
<li>Align test terminology with stakeholder language to ensure mutual understanding.</li>
<li>Create assertions as separate validation layers to confirm functional correctness.</li>
<li>Modularize end-to-end tests into smaller test suites for scalability and resilience.</li>
<li>Reserve test setup and teardown actions for designated files outside the core tests.</li>
<li>Prefix assertion keywords with terms like “validate” for immediate recognition.</li>
<li>Consolidate locator usage within keywords to reduce redundancy and errors.</li>
<li>Develop tests incrementally to parallelize work on system readiness and test case creation.</li>
<li>Utilize consistent conventions for page and business object layers to enhance readability.</li>
</ul>
<h2 id="facts">FACTS</h2>
<ul>
<li>Robot Framework allows modularization through resource file organization for better test management.</li>
<li>Test locators can often be simplified by avoiding dynamic parameters with developer collaboration.</li>
<li>Stakeholders may find technical test scripts overwhelming without functional abstraction layers.</li>
<li>Composite keywords must ensure their completion status before the next test step begins.</li>
<li>Modular test frameworks enable switching out unavailable or incomplete system components.</li>
<li>Validation steps are vital for ensuring test outcomes reflect real system behavior.</li>
<li>JSON is often used for system-to-system data transfer in end-to-end tests.</li>
<li>Consistent naming conventions in test frameworks improve scalability and reduce ambiguity.</li>
<li>Modularized end-to-end testing eases debugging and reduces system interdependencies.</li>
<li>Prefixes like &ldquo;validate&rdquo; distinguish validation steps from core test actions.</li>
</ul>
<h2 id="references">REFERENCES</h2>
<ul>
<li>Robot Framework documentation and best practices.</li>
<li>JSON as a format for system-to-system communication.</li>
<li>Giren language concepts for capturing stakeholder language in test layers.</li>
<li>Page Object and Business Object design patterns in test automation.</li>
</ul>
<h2 id="one-sentence-takeaway">ONE-SENTENCE TAKEAWAY</h2>
<p>Effective test automation frameworks rely on clear modularization, stakeholder alignment, and robust conventions for maintainability.</p>
<h2 id="recommendations">RECOMMENDATIONS</h2>
<ul>
<li>Modularize resource files to keep frameworks maintainable and scalable over time.</li>
<li>Use clear prefixes in naming conventions to eliminate ambiguity in keywords.</li>
<li>Validate every test case step to ensure accurate outcomes and prevent silent failures.</li>
<li>Separate technical complexities from business logic for improved stakeholder readability.</li>
<li>Engage stakeholders early to align test layers with domain language and requirements.</li>
<li>Collaborate with developers to avoid using dynamic locators wherever possible.</li>
<li>Split end-to-end tests into smaller suites for better debugging and flexibility.</li>
<li>Organize tests logically to enable team-wide understanding and collaboration.</li>
<li>Use assertion layers for validations without polluting business object layers.</li>
<li>Document conventions for team consistency across test automation frameworks.</li>
<li>Utilize titles or unique identifiers to manage dynamic elements in locators.</li>
<li>Place setup and teardown actions outside core test suites for clarity.</li>
<li>Develop tests incrementally to accommodate system readiness and parallel workflows.</li>
<li>Incorporate domain-specific language into business objects for stakeholder clarity.</li>
<li>Align test cases with stakeholder goals to enhance relevance and engagement.</li>
</ul>
<p><a href="https://youtu.be/v4gWC7GPxT4?si=_ScZLoAoEvh_ds3Y">https://youtu.be/v4gWC7GPxT4?si=_ScZLoAoEvh_ds3Y</a></p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/tag">tag</a></li>
					
					<li><a href="/tags/names">names</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/athul/archie" rel="me" title="GitHub"><i data-feather="github"></i></a>
    <a class="border"></a><a class="soc" href="https://twitter.com/athulcajay/" rel="me" title="Twitter"><i data-feather="twitter"></i></a>
    <a class="border"></a><a class="soc" href="https://gitlab.com/athul/" rel="me" title="GitLab"><i data-feather="gitlab"></i></a>
    <a class="border"></a></div>
  <div class="footer-info">
    2024  © Athul |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


<script>
  feather.replace()
</script></div>
    </body>
</html>
